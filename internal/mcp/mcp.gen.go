// Code generated by mcp-codegen. DO NOT EDIT.
package scrapbox

import (
	"context"
	"encoding/json"
	"fmt"
	"slices"

	mcp "github.com/ktr0731/go-mcp"
	"github.com/ktr0731/go-mcp/protocol"
)

// ServerPromptHandler is the interface for prompt handlers.
type ServerPromptHandler interface {
}

// ServerToolHandler is the interface for tool handlers.
type ServerToolHandler interface {
	HandleToolGetPage(ctx context.Context, req *ToolGetPageRequest) (*mcp.CallToolResult, error)
	HandleToolListPages(ctx context.Context, req *ToolListPagesRequest) (*mcp.CallToolResult, error)
	HandleToolSearchPages(ctx context.Context, req *ToolSearchPagesRequest) (*mcp.CallToolResult, error)
	HandleToolCreatePage(ctx context.Context, req *ToolCreatePageRequest) (*mcp.CallToolResult, error)
}

// ToolGetPageRequest contains input parameters for the get_page tool.
type ToolGetPageRequest struct {
	PageTitle string `json:"page_title"`
}

// ToolListPagesRequest contains input parameters for the list_pages tool.
type ToolListPagesRequest struct {
}

// ToolSearchPagesRequest contains input parameters for the search_pages tool.
type ToolSearchPagesRequest struct {
	Query string `json:"query"`
}

// ToolCreatePageRequest contains input parameters for the create_page tool.
type ToolCreatePageRequest struct {
	PageTitle string  `json:"page_title"`
	BodyText  *string `json:"body_text"`
}

// PromptList contains all available prompts.
var PromptList = []protocol.Prompt{}

// JSON Schema type definitions generated from inputSchema
var (
	ToolGetPageInputSchema     = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","$ref":"#/$defs/GetPageInput","$defs":{"GetPageInput":{"properties":{"page_title":{"type":"string","description":"Page title to retrieve"}},"additionalProperties":false,"type":"object","required":["page_title"]}}}`)
	ToolListPagesInputSchema   = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","properties":{},"additionalProperties":false,"type":"object"}`)
	ToolSearchPagesInputSchema = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","$ref":"#/$defs/SearchPagesInput","$defs":{"SearchPagesInput":{"properties":{"query":{"type":"string","description":"Search query"}},"additionalProperties":false,"type":"object","required":["query"]}}}`)
	ToolCreatePageInputSchema  = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","$ref":"#/$defs/CreatePageInput","$defs":{"CreatePageInput":{"properties":{"page_title":{"type":"string","description":"Title of the new page"},"body_text":{"type":"string","description":"Optional body text for the new page"}},"additionalProperties":false,"type":"object","required":["page_title","body_text"]}}}`)
)

// ToolList contains all available tools.
var ToolList = []protocol.Tool{
	{
		Name:        "get_page",
		Description: "Get page content from Scrapbox",
		InputSchema: ToolGetPageInputSchema,
	},
	{
		Name:        "list_pages",
		Description: "Get a list of pages in the project (max 1000 pages)",
		InputSchema: ToolListPagesInputSchema,
	},
	{
		Name:        "search_pages",
		Description: "Full-text search across all pages in the project (max 100 pages)",
		InputSchema: ToolSearchPagesInputSchema,
	},
	{
		Name:        "create_page",
		Description: "Create a new page",
		InputSchema: ToolCreatePageInputSchema,
	},
}

// NewHandler creates a new MCP handler.
func NewHandler(toolHandler ServerToolHandler) *mcp.Handler {
	h := &mcp.Handler{}
	h.Capabilities = protocol.ServerCapabilities{
		Tools:   &protocol.ToolCapability{},
		Logging: &protocol.LoggingCapability{},
	}
	h.Implementation = protocol.Implementation{
		Name:    "Scrapbox MCP Server",
		Version: "1.0.0",
	}
	h.Tools = ToolList
	h.ToolHandler = protocol.ServerHandlerFunc[protocol.CallToolRequestParams](func(ctx context.Context, method string, req protocol.CallToolRequestParams) (any, error) {
		idx := slices.IndexFunc(ToolList, func(t protocol.Tool) bool {
			return t.Name == req.Name
		})
		if idx == -1 {
			return nil, fmt.Errorf("tool not found: %s", req.Name)
		}
		switch method {
		case "tools/call":
			switch req.Name {
			case "get_page":
				var in ToolGetPageRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolGetPage(ctx, &in)
			case "list_pages":
				var in ToolListPagesRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolListPages(ctx, &in)
			case "search_pages":
				var in ToolSearchPagesRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolSearchPages(ctx, &in)
			case "create_page":
				var in ToolCreatePageRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolCreatePage(ctx, &in)
			default:
				return nil, fmt.Errorf("tool not found: %s", req.Name)
			}
		default:
			return nil, fmt.Errorf("method %s not found", method)
		}
	})
	return h
}
